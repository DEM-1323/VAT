<!DOCTYPE html>
<html>
  <head>
    <title>Babylon.js VR Auscultation Trainer</title>
    <style>
      html,
      body {
        width: 100%;
        height: 100%;
        margin: 0;
        overflow: hidden;
      }
      #renderCanvas {
        width: 100%;
        height: 100%;
        touch-action: none;
        display: none;
      }
      #startButton {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        padding: 10px 20px;
        font-size: 20px;
        cursor: pointer;
      }
    </style>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylon.glTF2FileLoader.min.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
  </head>
  <body>
    <button id="startButton">Start Experience</button>
    <canvas id="renderCanvas"></canvas>
    <script>
      let engine;
      let scene;
      let sounds = {};
      let audioContext;
      let triggersVisible = true;

      document
        .getElementById("startButton")
        .addEventListener("click", startExperience);

      async function startExperience() {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        if (audioContext.state === "suspended") {
          await audioContext.resume();
        }

        document.getElementById("startButton").style.display = "none";
        document.getElementById("renderCanvas").style.display = "block";

        const canvas = document.getElementById("renderCanvas");
        engine = new BABYLON.Engine(canvas, true);
        scene = createScene(engine, canvas);

        engine.runRenderLoop(() => scene.render());

        window.addEventListener("resize", () => engine.resize());
      }

      function createScene(engine, canvas) {
        const scene = new BABYLON.Scene(engine);
        scene.metadata = {
          triggers: [],
          controllers: [],
        };

        scene.audioEnabled = true;
        scene.audioPositioningRefreshRate = 100;

        const camera = new BABYLON.ArcRotateCamera(
          "Camera",
          Math.PI / 2,
          Math.PI / 2,
          2,
          new BABYLON.Vector3(0, 0.5, 0),
          scene
        );
        camera.attachControl(canvas, true);

        // Add ambient light
        const ambientLight = new BABYLON.HemisphericLight(
          "ambientLight",
          new BABYLON.Vector3(0, 1, 0),
          scene
        );
        ambientLight.intensity = 0.7;

        // Add directional light for shadows and depth
        const directionalLight = new BABYLON.DirectionalLight(
          "directionalLight",
          new BABYLON.Vector3(-1, -2, -1),
          scene
        );
        directionalLight.intensity = 0.5;

        const floor = createRoom(scene);
        createSounds(scene);
        initializeXR(scene, floor);

        loadModel(scene, "models/", "SAMII.glb")
          .then((importedMesh) => {
            importedMesh.position = BABYLON.Vector3.Zero();
            importedMesh.rotation = new BABYLON.Vector3(0, -2.9, 0);
            createTriggerPoints(scene, importedMesh, sounds);
            configureTriggerActionsForAllControllers(scene);
          })
          .catch((error) => {
            console.error("Model failed to load:", error);
          });

        return scene;
      }

      function createRoom(scene) {
        // Room dimensions
        const roomWidth = 5;
        const roomDepth = 5;
        const roomHeight = 3;
        const wallThickness = 0.1;

        // Create material for room elements
        const roomMaterial = new BABYLON.StandardMaterial(
          "roomMaterial",
          scene
        );
        roomMaterial.diffuseColor = new BABYLON.Color3(0.95, 0.95, 0.95);
        roomMaterial.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);

        // Create floor
        const floor = BABYLON.MeshBuilder.CreateGround(
          "floor",
          { width: roomWidth, height: roomDepth },
          scene
        );
        floor.material = roomMaterial;

        // Create ceiling
        const ceiling = BABYLON.MeshBuilder.CreateGround(
          "ceiling",
          { width: roomWidth, height: roomDepth },
          scene
        );
        ceiling.position.y = roomHeight;
        ceiling.rotation.x = Math.PI;
        ceiling.material = roomMaterial;

        // Create walls that meet perfectly at corners
        const wallConfigurations = [
          // Front and back walls (full width)
          {
            position: new BABYLON.Vector3(0, roomHeight / 2, -roomDepth / 2),
            dimensions: {
              width: roomWidth,
              height: roomHeight + 0.001,
              depth: wallThickness,
            },
          },
          {
            position: new BABYLON.Vector3(0, roomHeight / 2, roomDepth / 2),
            dimensions: {
              width: roomWidth,
              height: roomHeight + 0.001,
              depth: wallThickness,
            },
          },
          // Side walls (width reduced by wall thickness to fit perfectly)
          {
            position: new BABYLON.Vector3(-roomWidth / 2, roomHeight / 2, 0),
            dimensions: {
              width: wallThickness,
              height: roomHeight + 0.001,
              depth: roomDepth + wallThickness,
            },
          },
          {
            position: new BABYLON.Vector3(roomWidth / 2, roomHeight / 2, 0),
            dimensions: {
              width: wallThickness,
              height: roomHeight + 0.001,
              depth: roomDepth + wallThickness,
            },
          },
        ];

        wallConfigurations.forEach((config, index) => {
          const wall = BABYLON.MeshBuilder.CreateBox(
            `wall${index}`,
            config.dimensions,
            scene
          );
          // Position walls to start from floor level instead of being centered
          wall.position = new BABYLON.Vector3(
            config.position.x,
            config.dimensions.height / 2 + 0.1,
            config.position.z
          );
          wall.material = roomMaterial;
        });

        // Add baseboards with matching dimensions
        const baseboardMaterial = new BABYLON.StandardMaterial(
          "baseboardMaterial",
          scene
        );
        baseboardMaterial.diffuseColor = new BABYLON.Color3(0.2, 0.2, 0.2);

        wallConfigurations.forEach((config, index) => {
          const baseboard = BABYLON.MeshBuilder.CreateBox(
            `baseboard${index}`,
            {
              width: config.dimensions.width,
              height: 0.1,
              depth: config.dimensions.depth,
            },
            scene
          );
          baseboard.position = new BABYLON.Vector3(
            config.position.x,
            0.05,
            config.position.z
          );
          baseboard.material = baseboardMaterial;
        });

        return floor;
      }

      function createControllerUI(xrInput) {
        const guiManager = new BABYLON.GUI.GUI3DManager(scene);

        const button = new BABYLON.GUI.HolographicButton("toggleButton");
        guiManager.addControl(button);

        button.scaling = new BABYLON.Vector3(0.15, 0.15, 0.15);

        const text = new BABYLON.GUI.TextBlock();
        text.text = "Hide Triggers";
        text.color = "white";
        text.fontSize = 36;
        button.content = text;

        xrInput.onControllerAddedObservable.add((controller) => {
          if (controller.inputSource.handedness === "left") {
            button.linkToTransformNode(controller.grip);

            button.position = new BABYLON.Vector3(0, 0.08, 0.05);
            button.rotation = new BABYLON.Vector3(-0.3, 0, 0);
          }
        });

        button.onPointerDownObservable.add(() => {
          triggersVisible = !triggersVisible;
          text.text = triggersVisible ? "Hide Triggers" : "Show Triggers";

          scene.metadata.triggers.forEach(({ trigger }) => {
            trigger.isVisible = triggersVisible;
          });
        });
      }

      function createSounds(scene) {
        console.log("Loading sounds...");
        sounds.bronchial = new BABYLON.Sound(
          "bronchialSound",
          "audio/Bronchial.mp3",
          scene,
          () => console.log("Bronchial sound loaded successfully"),
          {
            loop: true,
            autoplay: false,
            spatialSound: true,
            distanceModel: "linear",
            maxDistance: 100,
            rolloffFactor: 1,
          }
        );

        sounds.bronchial.onLoadError = function (error) {
          console.error("Error loading bronchial sound:", error);
        };

        sounds.heart = new BABYLON.Sound(
          "normalHeartSound",
          "audio/Normal_heart.mp3",
          scene,
          () => console.log("Heart sound loaded successfully"),
          {
            loop: true,
            autoplay: false,
            spatialSound: true,
            distanceModel: "linear",
            maxDistance: 100,
            rolloffFactor: 1,
          }
        );

        sounds.heart.onLoadError = function (error) {
          console.error("Error loading heart sound:", error);
        };
      }

      function initializeXR(scene, floor) {
        scene
          .createDefaultXRExperienceAsync({
            floorMeshes: [floor],
          })
          .then((xr) => {
            scene.metadata.xr = xr;

            createControllerUI(xr.input);

            xr.input.onControllerAddedObservable.add((controller) => {
              console.log("Controller added:", controller);
              scene.metadata.controllers.push(controller);

              if (
                scene.metadata.triggers &&
                scene.metadata.triggers.length > 0
              ) {
                configureTriggerActionsForController(scene, controller);
              }
            });
          })
          .catch((error) => {
            console.error("Error initializing XR:", error);
          });
      }

      function loadModel(scene, rootUrl, fileName) {
        return new Promise((resolve, reject) => {
          BABYLON.SceneLoader.ImportMesh(
            "",
            rootUrl,
            fileName,
            scene,
            function (meshes) {
              const importedMesh = meshes[0];
              importedMesh.position = BABYLON.Vector3.Zero();
              resolve(importedMesh);
            },
            null,
            function (scene, message, exception) {
              reject({ message, exception });
            }
          );
        });
      }

      function createTriggerPoints(scene, importedMesh, sounds) {
        const trigger1 = BABYLON.MeshBuilder.CreateSphere(
          "trigger1",
          { diameter: 0.1 },
          scene
        );
        trigger1.position = new BABYLON.Vector3(0, 0.55, 0.1);
        trigger1.parent = importedMesh;
        trigger1.isVisible = triggersVisible;

        sounds.bronchial.attachToMesh(trigger1);

        scene.metadata.triggers.push({
          trigger: trigger1,
          sound: sounds.bronchial,
          isIntersecting: false,
        });

        const trigger2 = BABYLON.MeshBuilder.CreateSphere(
          "trigger2",
          { diameter: 0.1 },
          scene
        );
        trigger2.position = new BABYLON.Vector3(0.13, 0.47, 0.09);
        trigger2.parent = importedMesh;
        trigger2.isVisible = triggersVisible;

        sounds.heart.attachToMesh(trigger2);

        scene.metadata.triggers.push({
          trigger: trigger2,
          sound: sounds.heart,
          isIntersecting: false,
        });
      }

      function configureTriggerActionsForAllControllers(scene) {
        const { triggers, controllers } = scene.metadata;

        if (!triggers || triggers.length === 0) return;
        if (!controllers || controllers.length === 0) return;

        controllers.forEach((controller) => {
          configureTriggerActionsForController(scene, controller);
        });
      }

      function configureTriggerActionsForController(scene, controller) {
        const { triggers } = scene.metadata;
        if (!triggers || triggers.length === 0) return;

        if (!controller.grip) return;

        triggers.forEach(({ trigger, sound }) => {
          if (!trigger.actionManager) {
            trigger.actionManager = new BABYLON.ActionManager(scene);
          }

          trigger.actionManager.registerAction(
            new BABYLON.ExecuteCodeAction(
              {
                trigger: BABYLON.ActionManager.OnIntersectionEnterTrigger,
                parameter: {
                  mesh: controller.grip,
                  usePreciseIntersection: true,
                },
              },
              () => {
                if (!sound.isPlaying) {
                  console.log(`Playing ${sound.name}`);
                  sound.play();
                }
              }
            )
          );

          trigger.actionManager.registerAction(
            new BABYLON.ExecuteCodeAction(
              {
                trigger: BABYLON.ActionManager.OnIntersectionExitTrigger,
                parameter: {
                  mesh: controller.grip,
                  usePreciseIntersection: true,
                },
              },
              () => {
                if (sound.isPlaying) {
                  console.log(`Stopping ${sound.name}`);
                  sound.stop();
                }
              }
            )
          );
        });
      }
    </script>
  </body>
</html>
