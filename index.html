<!DOCTYPE html>
<html>
  <head>
    <title>Babylon.js VR Project</title>
    <style>
      html,
      body {
        width: 100%;
        height: 100%;
        margin: 0;
        overflow: hidden;
      }
      #renderCanvas {
        width: 100%;
        height: 100%;
        touch-action: none;
        display: none;
      }
      #startButton {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        padding: 10px 20px;
        font-size: 20px;
        cursor: pointer;
      }
    </style>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylon.glTF2FileLoader.min.js"></script>
  </head>
  <body>
    <button id="startButton">Start Experience</button>
    <canvas id="renderCanvas"></canvas>
    <script>
      let audioContext;
      let scene;
      let sounds = {};

      document
        .getElementById("startButton")
        .addEventListener("click", async () => {
          audioContext = new (window.AudioContext ||
            window.webkitAudioContext)();
          if (audioContext.state === "suspended") {
            await audioContext.resume();
          }

          document.getElementById("startButton").style.display = "none";
          document.getElementById("renderCanvas").style.display = "block";
          initializeScene();
        });

      function createSounds(scene) {
        console.log("Creating sound objects...");

        sounds.bronchial = new BABYLON.Sound(
          "bronchialSound",
          "audio/Bronchial.mp3",
          scene,
          function () {
            console.log("Bronchial sound loaded successfully");
          },
          {
            loop: true,
            autoplay: false,
            spatialSound: true,
            distanceModel: "linear",
            maxDistance: 100,
            rolloffFactor: 1,
          }
        );

        sounds.bronchial.onLoadError = function (error) {
          console.error("Error loading bronchial sound:", error);
        };
      }

      function initializeScene() {
        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true);

        const createScene = function () {
          scene = new BABYLON.Scene(engine);
          scene.audioEnabled = true;
          scene.audioPositioningRefreshRate = 100;

          // Create sounds first
          createSounds(scene);

          const camera = new BABYLON.ArcRotateCamera(
            "Camera",
            Math.PI / 2,
            Math.PI / 2,
            2,
            BABYLON.Vector3.Zero(),
            scene
          );
          camera.attachControl(canvas, true);

          const light = new BABYLON.HemisphericLight(
            "light",
            new BABYLON.Vector3(1, 1, 0),
            scene
          );

          const floor = BABYLON.MeshBuilder.CreateGround(
            "floor",
            { width: 10, height: 10 },
            scene
          );

          const floorMaterial = new BABYLON.StandardMaterial(
            "floorMaterial",
            scene
          );
          floorMaterial.diffuseColor = new BABYLON.Color3(0.5, 0.5, 0.5);
          floor.material = floorMaterial;

          BABYLON.SceneLoader.ImportMesh(
            "",
            "models/",
            "SAMII.glb",
            scene,
            function (meshes) {
              const importedMesh = meshes[0];
              importedMesh.position = new BABYLON.Vector3(0, 0, 0);
              createTriggerPoints(importedMesh);
            },
            null,
            function (scene, message, exception) {
              console.error("Error loading the model:", message, exception);
            }
          );

          const xrPromise = scene.createDefaultXRExperienceAsync({
            floorMeshes: [floor],
          });

          xrPromise.then((xr) => {
            xr.input.onControllerAddedObservable.add((controller) => {
              const controllerSphere = BABYLON.MeshBuilder.CreateSphere(
                "controller",
                {
                  diameter: 0.1,
                  segments: 8,
                },
                scene
              );
              controllerSphere.isVisible = false;

              // Use a single variable to track intersection state
              let lastIntersectionState = false;

              scene.registerBeforeRender(() => {
                // Check if metadata and triggers exist before proceeding
                if (!scene.metadata?.triggers) return;

                if (controller.grip) {
                  controllerSphere.position = controller.grip.position;

                  // Get the current intersection state and the corresponding trigger data
                  const intersectingTrigger = scene.metadata.triggers.find(
                    (triggerData) =>
                      controllerSphere.intersectsMesh(
                        triggerData.trigger,
                        false
                      )
                  );

                  const isCurrentlyIntersecting = !!intersectingTrigger;

                  // Only take action when the state changes
                  if (isCurrentlyIntersecting !== lastIntersectionState) {
                    if (isCurrentlyIntersecting && intersectingTrigger.sound) {
                      console.log(`Playing ${intersectingTrigger.sound.name}`);
                      intersectingTrigger.sound.play();
                    } else {
                      // Find the previously playing sound and stop it
                      scene.metadata.triggers.forEach((triggerData) => {
                        if (triggerData.sound && triggerData.sound.isPlaying) {
                          console.log(`Stopping ${triggerData.sound.name}`);
                          triggerData.sound.stop();
                        }
                      });
                    }
                    lastIntersectionState = isCurrentlyIntersecting;
                  }
                }
              });
            });
          });

          return scene;
        };

        scene = createScene();

        engine.runRenderLoop(function () {
          scene.render();
        });

        window.addEventListener("resize", function () {
          engine.resize();
        });
      }

      function createTriggerPoints(importedMesh) {
        const trigger1 = BABYLON.MeshBuilder.CreateSphere(
          "trigger1",
          { diameter: 0.2 },
          scene
        );
        trigger1.position = new BABYLON.Vector3(0, 0.5, 0.5);
        trigger1.isVisible = true;
        trigger1.parent = importedMesh;

        // Store trigger points and attach corresponding sounds
        scene.metadata = scene.metadata || {};
        scene.metadata.triggers = scene.metadata.triggers || [];

        // Attach the bronchial sound to the trigger point
        sounds.bronchial.attachToMesh(trigger1);

        scene.metadata.triggers.push({
          trigger: trigger1,
          sound: sounds.bronchial,
          isIntersecting: false,
        });
      }
    </script>
  </body>
</html>
